# Reading Files

Đọc file là hoạt động phổ biến của bất kì ngôn ngữ lập trình nào. Trong hướng dẫn này ta sẽ tìm hiểu về các đọc file bằng `go`

Hướng dẫn này có các phần sau

1. Đọc toàn bộ file vào bộ nhớ
   - Sử dụng đường dẫn file tuyệt đối
   - Truyền đường dẫn file dưới dạng `command line flag`
   - Bundling file bên trong nhị phân
2. Đọc 1 file theo từng đoạn nhỏ
3. Đọc từng dòng file

## Đọc toàn bộ file vào bộ nhớ

Một trong những thao tác cơ bản nhất với file là đọc toàn bộ file vào bộ nhớ "memory". Điều này được thực hiện bằng hàm `Readline` của gói `os`

Example:

```
├── Documents
│   └── filehandling
│       ├── filehandling.go
|       ├── go.mod
│       └── test.txt
```

```
package main

import (
	"fmt"
	"os"
)

func main() {
	contents, err := os.ReadFile("test.txt")
	if err != nil {
		fmt.Println("File reading error", err)
		return
	}
	fmt.Println("Contents of file:", string(contents))
}
```

1. Sử dụng đường dẫn file tuyệt đối

```
package main

import (
	"fmt"
	"os"
)

func main() {
	contents, err := os.ReadFile("/Users/andrew/Documents/filehandling/test.txt")
	if err != nil {
		fmt.Println("File reading error", err)
		return
	}
	fmt.Println("Contents of file:", string(contents))
}

```

Đây có vẻ là một cách dễ dàng nhưng lại có nhược điểm là tệp phải được đặt trong đường dẫn được chỉ định trong chương trình, nếu không phương pháp này sẽ thất bại.

2. Truyền đường dẫn tệp dưới dạng cờ dòng lệnh

Sử dụng gói `flag`, chúng ta có thể lấy đường dẫn tệp làm đối số đầu vào từ dòng lệnh và sau đó đọc nội dung của nó.

Gói `flag` có hàm `String`. Hàm này nhận 3 tham số.

    - arg1: tên của flag
    - arg2: giá trị mặc định
    - arg3: mô tả ngắn gọn về flag

```
package main

import (
	"flag"
	"fmt"
	"os"
)

func main() {
	fptr := flag.String("fpath", "test.txt", "file path to read from")
	flag.Parse()
	contents, err := os.ReadFile(*fptr)
	if err != nil {
		fmt.Println("File reading error", err)
		return
	}
	fmt.Println("Contents of file:", string(contents))
}
```

chương trình trên, tạo một string flag có tên `fpath` với giá trị mặc định `test.txt` và đường dẫn tệp mô tả để đọc bằng cách sử dụng hàm String. Hàm này trả về địa chỉ của biến chuỗi lưu trữ giá trị của flag.

`flag.Parse()` nên được gọi trước khi truy cập bất kỳ cờ nào.

> Khi chương trình này được chạy bằng lệnh

```
filehandling -fpath=/path-of-file/test.txt
```

`flag` cũng cung cấp đầu ra được định dạng độc đáo của các đối số khác nhau có sẵn. Điều này có thể được hiển thị bằng cách chạy

```
filehandling --help
```

```
Usage of filehandling:
  -fpath string
    	file path to read from (default "test.txt")
```

3. Bundling the text file along with the binary - "Đóng gói tệp văn bản cùng với tệp nhị phân"

Tùy chọn lấy đường dẫn tệp từ dòng lệnh ở trên là tốt nhưng có một cách thậm chí còn tốt hơn. Sẽ thật tuyệt vời nếu chúng ta có thể gói tệp văn bản cùng với tệp nhị phân của mình

Gói `embed` từ thư viện chuẩn sẽ giúp chúng ta đạt được điều này.

Sau khi nhập gói `embed`, lệnh //go:embed có thể được sử dụng để đọc nội dung của tệp.

```
package main

import (
	_ "embed"
	"fmt"
)

//go:embed test.txt
var contents []byte

func main() {
	fmt.Println("Contents of file:", string(contents))
}
```

Trong dòng 4 của chương trình trên, ta import gói `embed` có tiền tố gạch dưới. Lý do là vì embed không được sử dụng rõ ràng trong mã mà là nhận xét //go:embed ở dòng số 8 cần một số tiền xử lý của trình biên dịch. Vì ta cần nhập gói mà không có bất kỳ cách sử dụng rõ ràng nào, chúng tôi thêm tiền tố vào dấu gạch dưới để làm cho trình biên dịch hài lòng. Nếu không, trình biên dịch sẽ phàn nàn rằng gói không được sử dụng ở bất kỳ đâu.

> `//go:embed test.txt` ở dòng số 8 yêu cầu trình biên dịch đọc nội dung của test.txt và gán nó cho `biến theo nhận xét đó`. Trong trường hợp của chúng tôi, biến `contents` sẽ chứa nội dung của file.

```
# Run
cd ~/Documents/filehandling
go install
filehandling
# Output
....
```

Bây giờ, tệp được đóng gói cùng với tệp nhị phân và nó có sẵn cho tệp nhị phân go bất kể nó được thực thi từ đâu. Ví dụ: `hãy thử chạy chương trình từ thư mục không chứa test.txt`

```
cd ~/Documents
filehandling
```

Lệnh trên cũng sẽ in nội dung của tập tin.

`Xin lưu ý rằng biến mà nội dung của tệp được gán phải ở cấp gói. Các biến cục bộ sẽ không hoạt động`.

Hãy thử thay đổi chương trình như sau.

```
package main

import (
	_ "embed"
	"fmt"
)

func main() {
	//go:embed test.txt
	var contents []byte
	fmt.Println("Contents of file:", string(contents))
}
```

```
./filehandling.go:9:4: go:embed cannot apply to var inside func
```

## Đọc một tập tin theo từng đoạn nhỏ

Khi kích thước của tệp cực lớn, việc đọc toàn bộ tệp vào bộ nhớ sẽ không có ý nghĩa gì, đặc biệt nếu bạn sắp hết RAM.

Một cách tối ưu hơn là đọc tệp theo từng đoạn nhỏ. Điều này có thể được thực hiện với sự trợ giúp của gói `bufio`.

Hãy viết một chương trình đọc tệp test.txt của chúng tôi theo từng đoạn 3 byte. Thay thế nội dung của filehandling.go bằng nội dung sau:

```
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
)

func main() {
	fptr := flag.String("fpath", "test.txt", "file path to read from")
	flag.Parse()

	f, err := os.Open(*fptr)
	if err != nil {
		log.Fatal(err)
	}
	defer func() {
		if err = f.Close(); err != nil {
			log.Fatal(err)
		}
	}()

	r := bufio.NewReader(f)
	b := make([]byte, 3)
	for {
		n, err := r.Read(b)
		if err == io.EOF {
			fmt.Println("finished reading file")
			break
		}
		if err != nil {
			fmt.Printf("Error %s reading file", err)
			break
		}
		fmt.Println(string(b[0:n]))
	}
}
```

- Trong dòng 16 ta mở file bằng đường dẫn được truyền từ flag
- Trong dòng không 20, chúng tôi trì hoãn việc đóng file.
- Dòng số 26 tạo một trình đọc đệm mới. Trong dòng tiếp theo, chúng ta tạo một lát byte có độ dài và dung lượng 3 để đọc các byte của tệp.
- Phương thức Read ở dòng số 29 đọc tối đa len(b) byte, tức là tối đa 3 byte và trả về số byte đã đọc. Chúng tôi lưu trữ các byte được trả về trong một biến.
- Trong dòng không 38, lát cắt được đọc từ chỉ mục 0 đến n-1, tức là lên đến số byte được phương thức Đọc trả về và được in.
- Khi đến cuối tệp, quá trình đọc sẽ trả về lỗi EOF. Chúng tôi kiểm tra lỗi này ở dòng số 30.

## Đọc từng dòng file

Điều này có thể được thực hiện bằng cách sử dụng gói `bufio`.

Sau đây là các bước liên quan đến việc đọc từng dòng tệp.

1. Open file
2. Tạo một `Scanner` từ file
3. Quét tập tin và đọc từng dòng một.

```
package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
)

func main() {
	fptr := flag.String("fpath", "test.txt", "file path to read from")
	flag.Parse()

	f, err := os.Open(*fptr)
	if err != nil {
		log.Fatal(err)
	}
    defer func() {
	    if err = f.Close(); err != nil {
		log.Fatal(err)
	}
	}()
	s := bufio.NewScanner(f)
	for s.Scan() {
		fmt.Println(s.Text())
	}
	err = s.Err()
	if err != nil {
		log.Fatal(err)
	}
}
```
- Line 15, ta mở file bằng đường dẫn được truyền từ flag.
- Line 24, tạo một máy quét - scanner mới để sử dụng file.

- Phương thức scan() ở dòng số 25 đọc dòng tiếp theo của tệp và chuỗi được đọc sẽ có sẵn thông qua phương thức text().
# Writing Files
